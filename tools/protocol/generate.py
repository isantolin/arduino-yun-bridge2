#!/usr/bin/env python3
"""Protocol binding generator for Yun Bridge v2.

Reads spec.toml and generates:
1. Python bindings (yunbridge/rpc/protocol.py)
2. C++ bindings (openwrt-library-arduino/src/protocol/rpc_protocol.h)
"""

import argparse
import json
import sys
import textwrap
from pathlib import Path
from typing import Any, TextIO
import tomllib


HEADER = """/*
 * This file is part of Arduino Yun Ecosystem v2.
 * Copyright (C) 2025 Ignacio Santolin and contributors
 *
 * Auto-generated by tools/protocol/generate.py. DO NOT EDIT.
 */"""

PY_HEADER = """\"\"\"Auto-generated protocol bindings. Do not edit manually.\"\"\"
from __future__ import annotations
import struct
from enum import IntEnum, StrEnum
from typing import Final
"""


def _write_python_str_constant(
    out: TextIO,
    name: str,
    value: str,
    *,
    max_line_length: int = 120,
    wrap_width: int = 88,
) -> None:
    prefix = f"{name}: Final[str] = "
    literal = json.dumps(value)
    line = f"{prefix}{literal}"
    if len(line) <= max_line_length:
        out.write(f"{line}\n")
        return

    chunks = textwrap.wrap(
        value,
        width=wrap_width,
        break_long_words=False,
        break_on_hyphens=False,
    )
    if not chunks:
        out.write(f"{prefix}{literal}\n")
        return

    if len(chunks) > 1:
        chunks = [chunk + " " for chunk in chunks[:-1]] + [chunks[-1]]

    out.write(f"{name}: Final[str] = (\n")
    for chunk in chunks:
        out.write(f"    {json.dumps(chunk)}\n")
    out.write(")\n")


def _python_action_group_class_name(prefix: str) -> str:
    mapping = {
        "DATASTORE": "Datastore",
    }
    stem = mapping.get(prefix) or prefix.lower().title()
    return f"{stem}Action"


def _python_topic_action_enum_class(topic_name: str) -> str | None:
    mapping = {
        "ANALOG": "AnalogAction",
        "CONSOLE": "ConsoleAction",
        "DATASTORE": "DatastoreAction",
        "DIGITAL": "DigitalAction",
        "FILE": "FileAction",
        "MAILBOX": "MailboxAction",
        "SHELL": "ShellAction",
        "SYSTEM": "SystemAction",
    }
    return mapping.get(topic_name)


def _python_action_member_by_prefix(spec: dict[str, Any]) -> dict[str, dict[str, str]]:
    lookup: dict[str, dict[str, str]] = {}
    for action in spec.get("actions", []):
        raw_name = str(action["name"])
        if "_" not in raw_name:
            continue
        prefix, suffix = raw_name.split("_", 1)
        lookup.setdefault(prefix, {})[str(action["value"])] = suffix
    return lookup


def _python_mqtt_segment_expr(
    *,
    topic_name: str,
    seg: str,
    action_member_by_prefix: dict[str, dict[str, str]],
) -> str:
    if seg == "+":
        return "MQTT_WILDCARD_SINGLE"
    if seg == "#":
        return "MQTT_WILDCARD_MULTI"

    enum_class = _python_topic_action_enum_class(topic_name)
    if enum_class is not None:
        member = action_member_by_prefix.get(topic_name, {}).get(seg)
        if member is not None:
            return f"{enum_class}.{member}.value"

    return json.dumps(seg)


def _write_python_mqtt_subscriptions(out: TextIO, spec: dict[str, Any]) -> None:
    mqtt_subscriptions = spec.get("mqtt_subscriptions")
    if not mqtt_subscriptions:
        return

    out.write(
        "MQTT_COMMAND_SUBSCRIPTIONS: Final[tuple[tuple[Topic, tuple[str, ...], int], ...]] = (\n"
    )

    action_member_by_prefix = _python_action_member_by_prefix(spec)

    for entry in mqtt_subscriptions:
        topic_name = str(entry["topic"]).strip()
        segments = entry.get("segments") or []
        if not isinstance(segments, list):
            raise TypeError("mqtt_subscriptions.segments must be a list")
        qos = int(entry.get("qos", 0))
        topic_expr = f"Topic.{topic_name}"
        if segments:
            segment_expr = ", ".join(
                _python_mqtt_segment_expr(
                    topic_name=topic_name,
                    seg=str(seg),
                    action_member_by_prefix=action_member_by_prefix,
                )
                for seg in segments
            )
            out.write(f"    ({topic_expr}, ({segment_expr},), {qos}),\n")
        else:
            out.write(f"    ({topic_expr}, (), {qos}),\n")

    # flake8 expects two blank lines between top-level definitions.
    out.write(")\n\n\n")


def generate_cpp(spec: dict[str, Any], out: TextIO) -> None:
    out.write(f"{HEADER}\n")
    out.write("#ifndef RPC_PROTOCOL_H\n#define RPC_PROTOCOL_H\n\n")
    out.write('#include <stddef.h>\n')
    out.write('#include <stdint.h>\n\n')

    out.write("namespace rpc {\n\n")

    consts = spec["constants"]
    out.write(
        f"constexpr uint8_t PROTOCOL_VERSION = {consts['protocol_version']};\n"
    )
    out.write(
        f"constexpr unsigned long RPC_DEFAULT_BAUDRATE = {consts['default_baudrate']};\n"
    )
    if "default_safe_baudrate" in consts:
        out.write(
            f"constexpr unsigned long RPC_DEFAULT_SAFE_BAUDRATE = {consts['default_safe_baudrate']};\n"
        )
    if "max_payload_size" in consts:
        out.write(
            f"constexpr size_t MAX_PAYLOAD_SIZE = {consts['max_payload_size']};\n"
        )
    if "max_filepath_length" in consts:
        out.write(
            f"constexpr size_t RPC_MAX_FILEPATH_LENGTH = {consts['max_filepath_length']};\n"
        )
    if "max_datastore_key_length" in consts:
        out.write(
            f"constexpr size_t RPC_MAX_DATASTORE_KEY_LENGTH = {consts['max_datastore_key_length']};\n"
        )
    if "default_ack_timeout_ms" in consts:
        out.write(
            f"constexpr unsigned int RPC_DEFAULT_ACK_TIMEOUT_MS = {consts['default_ack_timeout_ms']};\n"
        )
    if "default_retry_limit" in consts:
        out.write(
            f"constexpr uint8_t RPC_DEFAULT_RETRY_LIMIT = {consts['default_retry_limit']};\n"
        )
    if "max_pending_tx_frames" in consts:
        out.write(
            f"constexpr uint8_t RPC_MAX_PENDING_TX_FRAMES = {consts['max_pending_tx_frames']};\n"
        )
    if "invalid_id_sentinel" in consts:
        out.write(
            f"constexpr uint16_t RPC_INVALID_ID_SENTINEL = {consts['invalid_id_sentinel']};\n"
        )
    if "uint8_mask" in consts:
        out.write(
            f"constexpr uint8_t RPC_UINT8_MASK = {consts['uint8_mask']};\n"
        )
    if "uint16_max" in consts:
        out.write(
            f"constexpr uint16_t RPC_UINT16_MAX = {consts['uint16_max']};\n"
        )
    if "process_default_exit_code" in consts:
        out.write(
            f"constexpr uint8_t RPC_PROCESS_DEFAULT_EXIT_CODE = {consts['process_default_exit_code']};\n"
        )
    if "crc32_mask" in consts:
        out.write(
            f"constexpr uint32_t RPC_CRC32_MASK = {consts['crc32_mask']};\n"
        )
    if "crc_initial" in consts:
        out.write(
            f"constexpr uint32_t RPC_CRC_INITIAL = {consts['crc_initial']};\n"
        )
    if "crc_polynomial" in consts:
        out.write(
            f"constexpr uint32_t RPC_CRC_POLYNOMIAL = {consts['crc_polynomial']};\n"
        )
    if "frame_delimiter" in consts:
        out.write(
            f"constexpr uint8_t RPC_FRAME_DELIMITER = {consts['frame_delimiter']};\n"
        )
    if "digital_low" in consts:
        out.write(
            f"constexpr uint8_t RPC_DIGITAL_LOW = {consts['digital_low']};\n"
        )
    if "digital_high" in consts:
        out.write(
            f"constexpr uint8_t RPC_DIGITAL_HIGH = {consts['digital_high']};\n"
        )
    if "status_code_min" in consts:
        out.write(
            f"constexpr uint8_t RPC_STATUS_CODE_MIN = {consts['status_code_min']};\n"
        )
    if "status_code_max" in consts:
        out.write(
            f"constexpr uint8_t RPC_STATUS_CODE_MAX = {consts['status_code_max']};\n"
        )
    if "system_command_min" in consts:
        out.write(
            f"constexpr uint16_t RPC_SYSTEM_COMMAND_MIN = {consts['system_command_min']};\n"
        )
    if "system_command_max" in consts:
        out.write(
            f"constexpr uint16_t RPC_SYSTEM_COMMAND_MAX = {consts['system_command_max']};\n"
        )
    if "gpio_command_min" in consts:
        out.write(
            f"constexpr uint16_t RPC_GPIO_COMMAND_MIN = {consts['gpio_command_min']};\n"
        )
    out.write("\n")

    handshake = spec.get("handshake", {})
    if handshake:
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_NONCE_LENGTH = {handshake['nonce_length']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_TAG_LENGTH = {handshake['tag_length']};\n"
        )
        out.write("constexpr unsigned int RPC_HANDSHAKE_CONFIG_SIZE = 7;\n")
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_ACK_TIMEOUT_MIN_MS = {handshake['ack_timeout_min_ms']};\n"
        )
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_ACK_TIMEOUT_MAX_MS = {handshake['ack_timeout_max_ms']};\n"
        )
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS = {handshake['response_timeout_min_ms']};\n"
        )
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS = {handshake['response_timeout_max_ms']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RETRY_LIMIT_MIN = {handshake['retry_limit_min']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RETRY_LIMIT_MAX = {handshake['retry_limit_max']};\n\n"
        )

    out.write("enum class StatusCode : uint8_t {\n")
    for status in spec["statuses"]:
        out.write(f"    STATUS_{status['name']} = {status['value']},\n")
    out.write("};\n\n")

    out.write("enum class CommandId : uint16_t {\n")
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']},\n")
    out.write("};\n\n")

    out.write("""
constexpr uint8_t to_underlying(StatusCode value) {
    return static_cast<uint8_t>(value);
}

constexpr uint16_t to_underlying(CommandId value) {
    return static_cast<uint16_t>(value);
}
""")
    out.write("} // namespace rpc\n#endif\n")


def generate_python(spec: dict[str, Any], out: TextIO) -> None:
    out.write(PY_HEADER + "\n")
    consts = spec["constants"]
    out.write(f"PROTOCOL_VERSION: Final[int] = {consts['protocol_version']}\n")
    out.write(f"DEFAULT_BAUDRATE: Final[int] = {consts['default_baudrate']}\n")
    if "default_safe_baudrate" in consts:
        out.write(
            f"DEFAULT_SAFE_BAUDRATE: Final[int] = {consts['default_safe_baudrate']}\n"
        )
    out.write(f"MAX_PAYLOAD_SIZE: Final[int] = {consts['max_payload_size']}\n")
    if "max_filepath_length" in consts:
        out.write(
            f"MAX_FILEPATH_LENGTH: Final[int] = {consts['max_filepath_length']}\n"
        )
    if "max_datastore_key_length" in consts:
        out.write(
            f"MAX_DATASTORE_KEY_LENGTH: Final[int] = {consts['max_datastore_key_length']}\n"
        )
    if "default_ack_timeout_ms" in consts:
        out.write(
            f"DEFAULT_ACK_TIMEOUT_MS: Final[int] = {consts['default_ack_timeout_ms']}\n"
        )
    if "default_retry_limit" in consts:
        out.write(
            f"DEFAULT_RETRY_LIMIT: Final[int] = {consts['default_retry_limit']}\n"
        )
    if "max_pending_tx_frames" in consts:
        out.write(
            f"MAX_PENDING_TX_FRAMES: Final[int] = {consts['max_pending_tx_frames']}\n"
        )
    if "invalid_id_sentinel" in consts:
        out.write(
            f"INVALID_ID_SENTINEL: Final[int] = {consts['invalid_id_sentinel']}\n"
        )
    if "uint8_mask" in consts:
        out.write(
            f"UINT8_MASK: Final[int] = {consts['uint8_mask']}\n"
        )
    if "uint16_max" in consts:
        out.write(
            f"UINT16_MAX: Final[int] = {consts['uint16_max']}\n"
        )
    if "process_default_exit_code" in consts:
        out.write(
            f"PROCESS_DEFAULT_EXIT_CODE: Final[int] = {consts['process_default_exit_code']}\n"
        )
    if "crc32_mask" in consts:
        out.write(
            f"CRC32_MASK: Final[int] = {consts['crc32_mask']}\n"
        )
    if "crc_initial" in consts:
        out.write(
            f"CRC_INITIAL: Final[int] = {consts['crc_initial']}\n"
        )
    if "crc_polynomial" in consts:
        out.write(
            f"CRC_POLYNOMIAL: Final[int] = {consts['crc_polynomial']}\n"
        )
    if "frame_delimiter" in consts:
        out.write(
            f"FRAME_DELIMITER: Final[bytes] = bytes([{consts['frame_delimiter']}])\n"
        )
    if "digital_low" in consts:
        out.write(
            f"DIGITAL_LOW: Final[int] = {consts['digital_low']}\n"
        )
    if "digital_high" in consts:
        out.write(
            f"DIGITAL_HIGH: Final[int] = {consts['digital_high']}\n"
        )
    if "status_code_min" in consts:
        out.write(
            f"STATUS_CODE_MIN: Final[int] = {consts['status_code_min']}\n"
        )
    if "status_code_max" in consts:
        out.write(
            f"STATUS_CODE_MAX: Final[int] = {consts['status_code_max']}\n"
        )
    if "system_command_min" in consts:
        out.write(
            f"SYSTEM_COMMAND_MIN: Final[int] = {consts['system_command_min']}\n"
        )
    if "system_command_max" in consts:
        out.write(
            f"SYSTEM_COMMAND_MAX: Final[int] = {consts['system_command_max']}\n"
        )
    if "gpio_command_min" in consts:
        out.write(
            f"GPIO_COMMAND_MIN: Final[int] = {consts['gpio_command_min']}\n"
        )
    out.write("\n")

    handshake = spec.get("handshake", {})
    if handshake:
        out.write(f"HANDSHAKE_NONCE_LENGTH: Final[int] = {handshake['nonce_length']}\n")
        out.write(f"HANDSHAKE_TAG_LENGTH: Final[int] = {handshake['tag_length']}\n")
        out.write(
            f"HANDSHAKE_TAG_ALGORITHM: Final[str] = \"{handshake['tag_algorithm']}\"\n"
        )
        _write_python_str_constant(
            out,
            "HANDSHAKE_TAG_DESCRIPTION",
            handshake["tag_description"],
        )
        out.write(
            f"HANDSHAKE_CONFIG_FORMAT: Final[str] = \"{handshake['config_format']}\"\n"
        )
        _write_python_str_constant(
            out,
            "HANDSHAKE_CONFIG_DESCRIPTION",
            handshake["config_description"],
        )
        out.write(
            "HANDSHAKE_CONFIG_SIZE: Final[int] = struct.calcsize(HANDSHAKE_CONFIG_FORMAT)\n"
        )
        out.write(
            f"HANDSHAKE_ACK_TIMEOUT_MIN_MS: Final[int] = {handshake['ack_timeout_min_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_ACK_TIMEOUT_MAX_MS: Final[int] = {handshake['ack_timeout_max_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS: Final[int] = {handshake['response_timeout_min_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS: Final[int] = {handshake['response_timeout_max_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RETRY_LIMIT_MIN: Final[int] = {handshake['retry_limit_min']}\n"
        )
        out.write(
            f"HANDSHAKE_RETRY_LIMIT_MAX: Final[int] = {handshake['retry_limit_max']}\n\n"
        )

    formats = spec.get("data_formats", {})
    if formats:
        if "uint8_format" in formats:
            out.write(f"UINT8_FORMAT: Final[str] = \"{formats['uint8_format']}\"\n")
        if "uint16_format" in formats:
            out.write(f"UINT16_FORMAT: Final[str] = \"{formats['uint16_format']}\"\n")
        if "uint32_format" in formats:
            out.write(f"UINT32_FORMAT: Final[str] = \"{formats['uint32_format']}\"\n")
        if "pin_read_format" in formats:
            out.write(f"PIN_READ_FORMAT: Final[str] = \"{formats['pin_read_format']}\"\n")
        if "pin_write_format" in formats:
            out.write(f"PIN_WRITE_FORMAT: Final[str] = \"{formats['pin_write_format']}\"\n")
        out.write(
            f"DATASTORE_KEY_LEN_FORMAT: Final[str] = \"{formats['datastore_key_len_format']}\"\n"
        )
        out.write(
            "DATASTORE_KEY_LEN_SIZE: Final[int] = struct.calcsize(DATASTORE_KEY_LEN_FORMAT)\n"
        )
        out.write(
            f"DATASTORE_VALUE_LEN_FORMAT: Final[str] = \"{formats['datastore_value_len_format']}\"\n"
        )
        out.write(
            "DATASTORE_VALUE_LEN_SIZE: Final[int] = struct.calcsize(DATASTORE_VALUE_LEN_FORMAT)\n"
        )
        out.write(
            f"CRC_COVERED_HEADER_FORMAT: Final[str] = \"{formats['crc_covered_header_format']}\"\n"
        )
        out.write(
            "CRC_COVERED_HEADER_SIZE: Final[int] = struct.calcsize(CRC_COVERED_HEADER_FORMAT)\n"
        )
        out.write(f"CRC_FORMAT: Final[str] = \"{formats['crc_format']}\"\n")
        out.write("CRC_SIZE: Final[int] = struct.calcsize(CRC_FORMAT)\n")
        out.write("MIN_FRAME_SIZE: Final[int] = CRC_COVERED_HEADER_SIZE + CRC_SIZE\n\n\n")

    mqtt_suffixes = spec.get("mqtt_suffixes", {})
    if mqtt_suffixes:
        for key, value in mqtt_suffixes.items():
            name = f"MQTT_SUFFIX_{key.upper()}"
            out.write(f'{name}: Final[str] = "{value}"\n')
        out.write("\n\n")

    # MQTT wildcard segments used by MQTT subscriptions.
    out.write('MQTT_WILDCARD_SINGLE: Final[str] = "+"\n')
    out.write('MQTT_WILDCARD_MULTI: Final[str] = "#"\n\n\n')

    if "topics" in spec:
        out.write("class Topic(StrEnum):\n")
        for topic in spec["topics"]:
            out.write(
                f"    {topic['name']} = \"{topic['value']}\"  # {topic['description']}\n"
            )
        out.write("\n\n")

    if "actions" in spec:
        # NOTE: actions in spec.toml use a PREFIX_SUFFIX naming convention
        # (e.g. FILE_READ, SHELL_RUN_ASYNC). We intentionally generate per-topic
        # enums (FileAction, ShellAction, ...) instead of a single Action enum.
        # A single StrEnum cannot safely contain duplicate values like "read" or
        # "write" without creating aliases, which makes parsing/iteration brittle.

        grouped: dict[str, list[dict[str, Any]]] = {}
        for action in spec["actions"]:
            raw_name = str(action["name"])
            if "_" not in raw_name:
                raise ValueError(f"Action name must be PREFIX_SUFFIX (got {raw_name!r})")
            prefix, _suffix = raw_name.split("_", 1)
            grouped.setdefault(prefix, []).append(action)

        for prefix, actions in grouped.items():
            out.write(f"class {_python_action_group_class_name(prefix)}(StrEnum):\n")
            for action in actions:
                raw_name = str(action["name"])
                _prefix, suffix = raw_name.split("_", 1)
                out.write(
                    f"    {suffix} = \"{action['value']}\"  # {action['description']}\n"
                )
            out.write("\n\n")

    # Emit subscriptions after action enums so we can reference FooAction.BAR.value
    # for known segments (instead of repeating string literals).
    _write_python_mqtt_subscriptions(out, spec)

    out.write("class Status(IntEnum):\n")
    for status in spec["statuses"]:
        out.write(
            f"    {status['name']} = {status['value']}  # {status['description']}\n"
        )
    out.write("\n\n")

    out.write("class Command(IntEnum):\n")
    ack_only_commands = []
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']}\n")
        if cmd.get("requires_ack", False):
            ack_only_commands.append(f"Command.{cmd['name']}.value")

    if ack_only_commands:
        out.write("\n\nACK_ONLY_COMMANDS: frozenset[int] = frozenset({\n")
        for cmd_val in ack_only_commands:
            out.write(f"    {cmd_val},\n")
        out.write("})\n")


def main() -> None:
    default_spec = Path(__file__).resolve().parent / "spec.toml"
    default_cpp = (
        Path(__file__).resolve().parents[2]
        / "openwrt-library-arduino"
        / "src"
        / "protocol"
        / "rpc_protocol.h"
    )
    default_py = (
        Path(__file__).resolve().parents[2]
        / "openwrt-yun-bridge"
        / "yunbridge"
        / "rpc"
        / "protocol.py"
    )

    parser = argparse.ArgumentParser(description="Generate protocol bindings")
    parser.add_argument(
        "--spec",
        type=Path,
        default=default_spec,
        help=f"Path to spec.toml (default: {default_spec})",
    )
    parser.add_argument("--cpp", type=Path, help=f"Output C++ header (default: {default_cpp})")
    parser.add_argument("--py", type=Path, help=f"Output Python module (default: {default_py})")
    args = parser.parse_args()

    if args.cpp is None and args.py is None:
        args.cpp = default_cpp
        args.py = default_py

    with args.spec.open("rb") as f:
        spec = tomllib.load(f)

    if args.cpp is not None:
        args.cpp.parent.mkdir(parents=True, exist_ok=True)
        with args.cpp.open("w", encoding="utf-8") as f:
            generate_cpp(spec, f)
        sys.stdout.write(f"Generated {args.cpp}\n")

    if args.py is not None:
        args.py.parent.mkdir(parents=True, exist_ok=True)
        with args.py.open("w", encoding="utf-8") as f:
            generate_python(spec, f)
        sys.stdout.write(f"Generated {args.py}\n")


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""Protocol binding generator for Yun Bridge v2.

Reads spec.toml and generates:
1. Python bindings (yunbridge/rpc/protocol.py)
2. C++ bindings (openwrt-library-arduino/src/protocol/rpc_protocol.h)
"""

import argparse
from pathlib import Path
from typing import Any, TextIO
import tomllib


HEADER = """/*
 * This file is part of Arduino Yun Ecosystem v2.
 * Copyright (C) 2025 Ignacio Santolin and contributors
 *
 * Auto-generated by tools/protocol/generate.py. DO NOT EDIT.
 */"""

PY_HEADER = """\"\"\"Auto-generated protocol bindings. Do not edit manually.\"\"\"
from __future__ import annotations
import struct
from enum import IntEnum
from typing import Final
"""


def generate_cpp(spec: dict[str, Any], out: TextIO) -> None:
    out.write(f"{HEADER}\n")
    out.write("#ifndef RPC_PROTOCOL_H\n#define RPC_PROTOCOL_H\n\n")
    out.write('#include <cstdint>\n#include <type_traits>\n#include <utility>\n#include "rpc_frame.h"\n\n')

    consts = spec["constants"]
    out.write(
        f"static_assert(rpc::PROTOCOL_VERSION == {consts['protocol_version']}, \"Version mismatch\");\n"
    )
    out.write(
        f"constexpr unsigned long RPC_DEFAULT_BAUDRATE = {consts['default_baudrate']};\n"
    )
    out.write(
        f"constexpr unsigned int RPC_BUFFER_SIZE = {consts['rpc_buffer_size']};\n\n"
    )

    handshake = spec.get("handshake", {})
    if handshake:
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_NONCE_LENGTH = {handshake['nonce_length']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_TAG_LENGTH = {handshake['tag_length']};\n"
        )
        out.write("constexpr unsigned int RPC_HANDSHAKE_CONFIG_SIZE = 7;\n")
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_ACK_TIMEOUT_MIN_MS = {handshake['ack_timeout_min_ms']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_ACK_TIMEOUT_MAX_MS = {handshake['ack_timeout_max_ms']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS = {handshake['response_timeout_min_ms']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS = {handshake['response_timeout_max_ms']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RETRY_LIMIT_MIN = {handshake['retry_limit_min']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RETRY_LIMIT_MAX = {handshake['retry_limit_max']};\n\n"
        )

    out.write("namespace rpc {\n\n")

    out.write("enum class StatusCode : uint8_t {\n")
    for status in spec["statuses"]:
        out.write(f"    STATUS_{status['name']} = {status['value']},\n")
    out.write("};\n\n")

    out.write("enum class CommandId : uint16_t {\n")
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']},\n")
    out.write("};\n\n")

    out.write("""template <typename Enum>
constexpr auto to_underlying(Enum value) noexcept -> typename std::underlying_type<Enum>::type {
#if __cplusplus >= 202302L
    return std::to_underlying(value);
#else
    return static_cast<typename std::underlying_type<Enum>::type>(value);
#endif
}
""")
    out.write("} // namespace rpc\n#endif\n")


def generate_python(spec: dict[str, Any], out: TextIO) -> None:
    out.write(PY_HEADER + "\n")
    consts = spec["constants"]
    out.write(f"PROTOCOL_VERSION: Final[int] = {consts['protocol_version']}\n")
    out.write(f"DEFAULT_BAUDRATE: Final[int] = {consts['default_baudrate']}\n")
    out.write(f"MAX_PAYLOAD_SIZE: Final[int] = {consts['max_payload_size']}\n")
    out.write(f"RPC_BUFFER_SIZE: Final[int] = {consts['rpc_buffer_size']}\n\n")

    handshake = spec.get("handshake", {})
    if handshake:
        out.write(f"HANDSHAKE_NONCE_LENGTH: Final[int] = {handshake['nonce_length']}\n")
        out.write(f"HANDSHAKE_TAG_LENGTH: Final[int] = {handshake['tag_length']}\n")
        out.write(
            f"HANDSHAKE_TAG_ALGORITHM: Final[str] = \"{handshake['tag_algorithm']}\"\n"
        )
        out.write(
            f"HANDSHAKE_TAG_DESCRIPTION: Final[str] = \"{handshake['tag_description']}\"\n"
        )
        out.write(
            f"HANDSHAKE_CONFIG_FORMAT: Final[str] = \"{handshake['config_format']}\"\n"
        )
        out.write(
            f"HANDSHAKE_CONFIG_DESCRIPTION: Final[str] = \"{handshake['config_description']}\"\n"
        )
        out.write(
            "HANDSHAKE_CONFIG_SIZE: Final[int] = struct.calcsize(HANDSHAKE_CONFIG_FORMAT)\n"
        )
        out.write(
            f"HANDSHAKE_ACK_TIMEOUT_MIN_MS: Final[int] = {handshake['ack_timeout_min_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_ACK_TIMEOUT_MAX_MS: Final[int] = {handshake['ack_timeout_max_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS: Final[int] = {handshake['response_timeout_min_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS: Final[int] = {handshake['response_timeout_max_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RETRY_LIMIT_MIN: Final[int] = {handshake['retry_limit_min']}\n"
        )
        out.write(
            f"HANDSHAKE_RETRY_LIMIT_MAX: Final[int] = {handshake['retry_limit_max']}\n\n"
        )

    formats = spec.get("data_formats", {})
    if formats:
        out.write(
            f"DATASTORE_KEY_LEN_FORMAT: Final[str] = \"{formats['datastore_key_len_format']}\"\n"
        )
        out.write(
            "DATASTORE_KEY_LEN_SIZE: Final[int] = struct.calcsize(DATASTORE_KEY_LEN_FORMAT)\n"
        )
        out.write(
            f"DATASTORE_VALUE_LEN_FORMAT: Final[str] = \"{formats['datastore_value_len_format']}\"\n"
        )
        out.write(
            "DATASTORE_VALUE_LEN_SIZE: Final[int] = struct.calcsize(DATASTORE_VALUE_LEN_FORMAT)\n"
        )
        out.write(
            f"CRC_COVERED_HEADER_FORMAT: Final[str] = \"{formats['crc_covered_header_format']}\"\n"
        )
        out.write(
            "CRC_COVERED_HEADER_SIZE: Final[int] = struct.calcsize(CRC_COVERED_HEADER_FORMAT)\n"
        )
        out.write(f"CRC_FORMAT: Final[str] = \"{formats['crc_format']}\"\n")
        out.write("CRC_SIZE: Final[int] = struct.calcsize(CRC_FORMAT)\n")
        out.write("MIN_FRAME_SIZE: Final[int] = CRC_COVERED_HEADER_SIZE + CRC_SIZE\n\n\n")

    out.write("class Status(IntEnum):\n")
    for status in spec["statuses"]:
        out.write(
            f"    {status['name']} = {status['value']}  # {status['description']}\n"
        )
    out.write("\n\n")

    out.write("class Command(IntEnum):\n")
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']}\n")


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate protocol bindings")
    parser.add_argument("--spec", type=Path, required=True, help="Path to spec.toml")
    parser.add_argument("--cpp", type=Path, help="Output C++ header")
    parser.add_argument("--py", type=Path, help="Output Python module")
    args = parser.parse_args()

    with args.spec.open("rb") as f:
        spec = tomllib.load(f)

    if args.cpp:
        with args.cpp.open("w") as f:
            generate_cpp(spec, f)
        print(f"Generated {args.cpp}")

    if args.py:
        with args.py.open("w") as f:
            generate_python(spec, f)
        print(f"Generated {args.py}")


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""Protocol binding generator for MCU Bridge v2.

Reads spec.toml and generates:
1. Python bindings (mcubridge/protocol/protocol.py)
2. C++ bindings (openwrt-library-arduino/src/protocol/rpc_protocol.h)
"""

from __future__ import annotations

import argparse
import json
import sys
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import Any, TextIO

import tomllib

# =============================================================================
# Headers
# =============================================================================

CPP_HEADER = """/*
 * This file is part of Arduino MCU Ecosystem v2.
 * Copyright (C) 2025 Ignacio Santolin and contributors
 *
 * Auto-generated by tools/protocol/generate.py. DO NOT EDIT.
 */"""

PY_HEADER = '''"""Auto-generated protocol bindings. Do not edit manually."""
from __future__ import annotations
from construct import Int8ub, Int16ub, Int32ub, Int64ub, Struct, PascalString, PrefixedBytes  # type: ignore
from enum import IntEnum, StrEnum
from typing import Any, Final, cast
'''

# =============================================================================
# Data-driven constant definitions
# =============================================================================


@dataclass(frozen=True, slots=True)
class ConstDef:
    """Definition for a protocol constant."""

    spec_key: str
    cpp_type: str
    cpp_name: str
    py_name: str
    py_type: str = "int"
    py_format: str | None = None  # Custom format string for Python output


# Constants that MUST exist (no conditional check)
REQUIRED_CONSTANTS: tuple[ConstDef, ...] = (
    ConstDef("protocol_version", "uint8_t", "PROTOCOL_VERSION", "PROTOCOL_VERSION"),
    ConstDef("default_baudrate", "unsigned long", "RPC_DEFAULT_BAUDRATE", "DEFAULT_BAUDRATE"),
    ConstDef("max_payload_size", "size_t", "MAX_PAYLOAD_SIZE", "MAX_PAYLOAD_SIZE"),
)

# Optional constants (emitted only if present in spec)
OPTIONAL_CONSTANTS: tuple[ConstDef, ...] = (
    ConstDef("default_safe_baudrate", "unsigned long", "RPC_DEFAULT_SAFE_BAUDRATE", "DEFAULT_SAFE_BAUDRATE"),
    ConstDef("max_filepath_length", "size_t", "RPC_MAX_FILEPATH_LENGTH", "MAX_FILEPATH_LENGTH"),
    ConstDef("max_datastore_key_length", "size_t", "RPC_MAX_DATASTORE_KEY_LENGTH", "MAX_DATASTORE_KEY_LENGTH"),
    ConstDef("default_ack_timeout_ms", "unsigned int", "RPC_DEFAULT_ACK_TIMEOUT_MS", "DEFAULT_ACK_TIMEOUT_MS"),
    ConstDef("default_retry_limit", "uint8_t", "RPC_DEFAULT_RETRY_LIMIT", "DEFAULT_RETRY_LIMIT"),
    ConstDef("max_pending_tx_frames", "uint8_t", "RPC_MAX_PENDING_TX_FRAMES", "MAX_PENDING_TX_FRAMES"),
    ConstDef("invalid_id_sentinel", "uint16_t", "RPC_INVALID_ID_SENTINEL", "INVALID_ID_SENTINEL"),
    ConstDef("cmd_flag_compressed", "uint16_t", "RPC_CMD_FLAG_COMPRESSED", "CMD_FLAG_COMPRESSED"),
    ConstDef("uint8_mask", "uint8_t", "RPC_UINT8_MASK", "UINT8_MASK"),
    ConstDef("uint16_max", "uint16_t", "RPC_UINT16_MAX", "UINT16_MAX"),
    ConstDef("process_default_exit_code", "uint8_t", "RPC_PROCESS_DEFAULT_EXIT_CODE", "PROCESS_DEFAULT_EXIT_CODE"),
    ConstDef("crc32_mask", "uint32_t", "RPC_CRC32_MASK", "CRC32_MASK"),
    ConstDef("crc_initial", "uint32_t", "RPC_CRC_INITIAL", "CRC_INITIAL"),
    ConstDef("crc_polynomial", "uint32_t", "RPC_CRC_POLYNOMIAL", "CRC_POLYNOMIAL"),
    ConstDef("frame_delimiter", "uint8_t", "RPC_FRAME_DELIMITER", "FRAME_DELIMITER", py_format="bytes([{value}])"),
    ConstDef("digital_low", "uint8_t", "RPC_DIGITAL_LOW", "DIGITAL_LOW"),
    ConstDef("digital_high", "uint8_t", "RPC_DIGITAL_HIGH", "DIGITAL_HIGH"),
    # RLE compression constants
    ConstDef("rle_escape_byte", "uint8_t", "RPC_RLE_ESCAPE_BYTE", "RLE_ESCAPE_BYTE"),
    ConstDef("rle_min_run_length", "uint8_t", "RPC_RLE_MIN_RUN_LENGTH", "RLE_MIN_RUN_LENGTH"),
    ConstDef("rle_max_run_length", "uint16_t", "RPC_RLE_MAX_RUN_LENGTH", "RLE_MAX_RUN_LENGTH"),
    ConstDef("rle_single_escape_marker", "uint8_t", "RPC_RLE_SINGLE_ESCAPE_MARKER", "RLE_SINGLE_ESCAPE_MARKER"),
    # Command category ranges
    ConstDef("status_code_min", "uint8_t", "RPC_STATUS_CODE_MIN", "STATUS_CODE_MIN"),
    ConstDef("status_code_max", "uint8_t", "RPC_STATUS_CODE_MAX", "STATUS_CODE_MAX"),
    ConstDef("system_command_min", "uint16_t", "RPC_SYSTEM_COMMAND_MIN", "SYSTEM_COMMAND_MIN"),
    ConstDef("system_command_max", "uint16_t", "RPC_SYSTEM_COMMAND_MAX", "SYSTEM_COMMAND_MAX"),
    ConstDef("gpio_command_min", "uint16_t", "RPC_GPIO_COMMAND_MIN", "GPIO_COMMAND_MIN"),
    ConstDef("gpio_command_max", "uint16_t", "RPC_GPIO_COMMAND_MAX", "GPIO_COMMAND_MAX"),
    ConstDef("console_command_min", "uint16_t", "RPC_CONSOLE_COMMAND_MIN", "CONSOLE_COMMAND_MIN"),
    ConstDef("console_command_max", "uint16_t", "RPC_CONSOLE_COMMAND_MAX", "CONSOLE_COMMAND_MAX"),
    ConstDef("datastore_command_min", "uint16_t", "RPC_DATASTORE_COMMAND_MIN", "DATASTORE_COMMAND_MIN"),
    ConstDef("datastore_command_max", "uint16_t", "RPC_DATASTORE_COMMAND_MAX", "DATASTORE_COMMAND_MAX"),
    ConstDef("mailbox_command_min", "uint16_t", "RPC_MAILBOX_COMMAND_MIN", "MAILBOX_COMMAND_MIN"),
    ConstDef("mailbox_command_max", "uint16_t", "RPC_MAILBOX_COMMAND_MAX", "MAILBOX_COMMAND_MAX"),
    ConstDef("filesystem_command_min", "uint16_t", "RPC_FILESYSTEM_COMMAND_MIN", "FILESYSTEM_COMMAND_MIN"),
    ConstDef("filesystem_command_max", "uint16_t", "RPC_FILESYSTEM_COMMAND_MAX", "FILESYSTEM_COMMAND_MAX"),
    ConstDef("process_command_min", "uint16_t", "RPC_PROCESS_COMMAND_MIN", "PROCESS_COMMAND_MIN"),
    ConstDef("process_command_max", "uint16_t", "RPC_PROCESS_COMMAND_MAX", "PROCESS_COMMAND_MAX"),
)

# Handshake constants (from spec["handshake"])
HANDSHAKE_CONSTANTS: tuple[ConstDef, ...] = (
    ConstDef("nonce_length", "unsigned int", "RPC_HANDSHAKE_NONCE_LENGTH", "HANDSHAKE_NONCE_LENGTH"),
    ConstDef("tag_length", "unsigned int", "RPC_HANDSHAKE_TAG_LENGTH", "HANDSHAKE_TAG_LENGTH"),
    ConstDef("ack_timeout_min_ms", "uint32_t", "RPC_HANDSHAKE_ACK_TIMEOUT_MIN_MS", "HANDSHAKE_ACK_TIMEOUT_MIN_MS"),
    ConstDef("ack_timeout_max_ms", "uint32_t", "RPC_HANDSHAKE_ACK_TIMEOUT_MAX_MS", "HANDSHAKE_ACK_TIMEOUT_MAX_MS"),
    ConstDef(
        "response_timeout_min_ms",
        "uint32_t",
        "RPC_HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS",
        "HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS",
    ),
    ConstDef(
        "response_timeout_max_ms",
        "uint32_t",
        "RPC_HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS",
        "HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS",
    ),
    ConstDef("retry_limit_min", "unsigned int", "RPC_HANDSHAKE_RETRY_LIMIT_MIN", "HANDSHAKE_RETRY_LIMIT_MIN"),
    ConstDef("retry_limit_max", "unsigned int", "RPC_HANDSHAKE_RETRY_LIMIT_MAX", "HANDSHAKE_RETRY_LIMIT_MAX"),
    ConstDef("hkdf_output_length", "unsigned int", "RPC_HANDSHAKE_HKDF_OUTPUT_LENGTH", "HANDSHAKE_HKDF_OUTPUT_LENGTH"),
    ConstDef(
        "nonce_random_bytes", "unsigned int", "RPC_HANDSHAKE_NONCE_RANDOM_BYTES", "HANDSHAKE_NONCE_RANDOM_BYTES"
    ),
    ConstDef(
        "nonce_counter_bytes", "unsigned int", "RPC_HANDSHAKE_NONCE_COUNTER_BYTES", "HANDSHAKE_NONCE_COUNTER_BYTES"
    ),
)

# Handshake string constants (Python only)
HANDSHAKE_STRING_CONSTANTS: tuple[tuple[str, str], ...] = (
    ("tag_algorithm", "HANDSHAKE_TAG_ALGORITHM"),
    ("tag_description", "HANDSHAKE_TAG_DESCRIPTION"),
    ("config_format", "HANDSHAKE_CONFIG_FORMAT"),
    ("config_description", "HANDSHAKE_CONFIG_DESCRIPTION"),
    ("hkdf_algorithm", "HANDSHAKE_HKDF_ALGORITHM"),
    ("nonce_format_description", "HANDSHAKE_NONCE_FORMAT_DESCRIPTION"),
)

# Handshake bytes constants (Python only)
HANDSHAKE_BYTES_CONSTANTS: tuple[tuple[str, str], ...] = (
    ("hkdf_salt", "HANDSHAKE_HKDF_SALT"),
    ("hkdf_info_auth", "HANDSHAKE_HKDF_INFO_AUTH"),
)

# Construct format mapping
CONSTRUCT_MAPPING: dict[str, str] = {
    "datastore_key_len_format": "Int8ub",
    "datastore_value_len_format": "Int8ub",
    "crc_covered_header_format": (
        "Struct(\n"
        '    "version" / Int8ub,\n'
        '    "payload_len" / Int16ub,\n'
        '    "command_id" / Int16ub,\n'
        ")"
    ),
    "crc_format": "Int32ub",
    "uint8_format": "Int8ub",
    "uint16_format": "Int16ub",
    "uint32_format": "Int32ub",
    "pin_read_format": "Int8ub",
    "pin_write_format": (
        "Struct(\n" '    "pin" / Int8ub,\n' '    "value" / Int8ub,\n' ")"
    ),
    "capabilities_format": (
        "Struct(\n"
        '    "ver" / Int8ub,\n'
        '    "arch" / Int8ub,\n'
        '    "dig" / Int8ub,\n'
        '    "ana" / Int8ub,\n'
        '    "feat" / Int32ub,\n'
        ")"
    ),
    "nonce_counter_format": "Int64ub",
}

# Topic -> Action enum class mapping
TOPIC_ACTION_ENUM_MAP: dict[str, str] = {
    "ANALOG": "AnalogAction",
    "CONSOLE": "ConsoleAction",
    "DATASTORE": "DatastoreAction",
    "DIGITAL": "DigitalAction",
    "FILE": "FileAction",
    "MAILBOX": "MailboxAction",
    "SHELL": "ShellAction",
    "SYSTEM": "SystemAction",
}


# =============================================================================
# Helper functions
# =============================================================================


def _write_cpp_const(out: TextIO, ctype: str, name: str, value: Any) -> None:
    """Write a single C++ constexpr constant."""
    out.write(f"constexpr {ctype} {name} = {value};\n")


def _write_cpp_constants(out: TextIO, source: dict[str, Any], defs: tuple[ConstDef, ...], required: bool) -> None:
    """Write C++ constants from a definition list."""
    for defn in defs:
        if defn.spec_key in source:
            _write_cpp_const(out, defn.cpp_type, defn.cpp_name, source[defn.spec_key])
        elif required:
            raise KeyError(f"Required constant '{defn.spec_key}' missing from spec")


def _write_py_const(out: TextIO, name: str, value: Any, py_type: str = "int", fmt: str | None = None) -> None:
    """Write a single Python Final constant."""
    if fmt:
        formatted = fmt.format(value=value)
        out.write(f"{name}: Final[{py_type}] = {formatted}\n")
    else:
        out.write(f"{name}: Final[{py_type}] = {value}\n")


def _write_py_constants(out: TextIO, source: dict[str, Any], defs: tuple[ConstDef, ...], required: bool) -> None:
    """Write Python constants from a definition list."""
    for defn in defs:
        if defn.spec_key in source:
            py_type = "bytes" if defn.py_format and "bytes" in defn.py_format else defn.py_type
            _write_py_const(out, defn.py_name, source[defn.spec_key], py_type, defn.py_format)
        elif required:
            raise KeyError(f"Required constant '{defn.spec_key}' missing from spec")


def _write_python_str_constant(
    out: TextIO,
    name: str,
    value: str,
    *,
    max_line_length: int = 120,
    wrap_width: int = 88,
) -> None:
    """Write a Python string constant with optional line wrapping."""
    prefix = f"{name}: Final[str] = "
    literal = json.dumps(value)
    line = f"{prefix}{literal}"

    if len(line) <= max_line_length:
        out.write(f"{line}\n")
        return

    chunks = textwrap.wrap(value, width=wrap_width, break_long_words=False, break_on_hyphens=False)
    if not chunks:
        out.write(f"{prefix}{literal}\n")
        return

    if len(chunks) > 1:
        chunks = [chunk + " " for chunk in chunks[:-1]] + [chunks[-1]]

    out.write(f"{name}: Final[str] = (\n")
    for chunk in chunks:
        out.write(f"    {json.dumps(chunk)}\n")
    out.write(")\n")


def _string_to_cpp_bytes(s: str) -> str:
    """Convert string to C++ byte array initializer."""
    return ", ".join(f"0x{ord(c):02X}" for c in s)


def _action_group_class_name(prefix: str) -> str:
    """Get Python enum class name for action group."""
    special = {"DATASTORE": "Datastore"}
    stem = special.get(prefix) or prefix.lower().title()
    return f"{stem}Action"


def _build_action_member_lookup(spec: dict[str, Any]) -> dict[str, dict[str, str]]:
    """Build lookup: prefix -> {value -> suffix}."""
    lookup: dict[str, dict[str, str]] = {}
    for action in spec.get("actions", []):
        raw_name = str(action["name"])
        if "_" not in raw_name:
            continue
        prefix, suffix = raw_name.split("_", 1)
        lookup.setdefault(prefix, {})[str(action["value"])] = suffix
    return lookup


def _mqtt_segment_expr(topic_name: str, seg: str, action_lookup: dict[str, dict[str, str]]) -> str:
    """Convert MQTT segment to Python expression."""
    if seg == "+":
        return "MQTT_WILDCARD_SINGLE"
    if seg == "#":
        return "MQTT_WILDCARD_MULTI"

    enum_class = TOPIC_ACTION_ENUM_MAP.get(topic_name)
    if enum_class:
        member = action_lookup.get(topic_name, {}).get(seg)
        if member:
            return f"{enum_class}.{member}.value"

    return json.dumps(seg)


# =============================================================================
# C++ Generator
# =============================================================================


def generate_cpp(spec: dict[str, Any], out: TextIO) -> None:
    """Generate C++ protocol header."""
    out.write(f"{CPP_HEADER}\n")
    out.write("#ifndef RPC_PROTOCOL_H\n#define RPC_PROTOCOL_H\n\n")
    out.write("#include <stddef.h>\n#include <stdint.h>\n\n")
    out.write("namespace rpc {\n\n")

    consts = spec["constants"]

    # Write constants using data-driven approach
    _write_cpp_constants(out, consts, REQUIRED_CONSTANTS, required=True)
    _write_cpp_constants(out, consts, OPTIONAL_CONSTANTS, required=False)
    out.write("\n")

    # Handshake section
    handshake = spec.get("handshake", {})
    if handshake:
        _write_cpp_constants(out, handshake, HANDSHAKE_CONSTANTS, required=False)
        _write_cpp_const(out, "unsigned int", "RPC_HANDSHAKE_CONFIG_SIZE", 7)

        # HKDF byte arrays (special handling)
        if "hkdf_salt" in handshake:
            salt = handshake["hkdf_salt"]
            out.write(f"constexpr uint8_t RPC_HANDSHAKE_HKDF_SALT[] = {{{_string_to_cpp_bytes(salt)}}};\n")
            out.write(f"constexpr size_t RPC_HANDSHAKE_HKDF_SALT_LEN = {len(salt)};\n")
        if "hkdf_info_auth" in handshake:
            info = handshake["hkdf_info_auth"]
            out.write(f"constexpr uint8_t RPC_HANDSHAKE_HKDF_INFO_AUTH[] = {{{_string_to_cpp_bytes(info)}}};\n")
            out.write(f"constexpr size_t RPC_HANDSHAKE_HKDF_INFO_AUTH_LEN = {len(info)};\n")
        out.write("\n")

    # Compression types
    compression = spec.get("compression", {})
    if compression:
        out.write("enum class CompressionType : uint8_t {\n")
        for key, value in compression.items():
            out.write(f"    COMPRESSION_{key.upper()} = {value},\n")
        out.write("};\n\n")

    # Capabilities
    capabilities = spec.get("capabilities", {})
    if capabilities:
        for key, value in capabilities.items():
            _write_cpp_const(out, "uint32_t", f"RPC_CAPABILITY_{key.upper()}", value)
        out.write("\n")

    # Status enum
    out.write("enum class StatusCode : uint8_t {\n")
    for status in spec["statuses"]:
        out.write(f"    STATUS_{status['name']} = {status['value']},\n")
    out.write("};\n\n")

    # Command enum
    out.write("enum class CommandId : uint16_t {\n")
    ack_only_cmds = []
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']},\n")
        if cmd.get("requires_ack", False):
            ack_only_cmds.append(cmd['name'])
    out.write("};\n\n")

    # Helper functions
    out.write("constexpr uint8_t to_underlying(StatusCode value) {\n")
    out.write("    return static_cast<uint8_t>(value);\n")
    out.write("}\n\n")
    out.write("constexpr uint16_t to_underlying(CommandId value) {\n")
    out.write("    return static_cast<uint16_t>(value);\n")
    out.write("}\n\n")

    # requires_ack Helper
    out.write("constexpr bool requires_ack(CommandId command_id) {\n")
    if ack_only_cmds:
        out.write("    return ")
        out.write(" ||\n           ".join([f"(command_id == CommandId::{cmd_name})" for cmd_name in ack_only_cmds]))
        out.write(";\n")
    else:
        out.write("    return false;\n")
    out.write("}\n\n")

    out.write("constexpr bool requires_ack(uint16_t command_id) {\n")
    out.write("    return requires_ack(static_cast<CommandId>(command_id));\n")
    out.write("}\n\n")

    out.write("} // namespace rpc\n#endif\n")


# =============================================================================
# Python Generator
# =============================================================================


def _write_python_handshake(out: TextIO, handshake: dict[str, Any]) -> None:
    """Write Python handshake constants."""
    _write_py_constants(out, handshake, HANDSHAKE_CONSTANTS, required=False)

    # String constants
    for spec_key, py_name in HANDSHAKE_STRING_CONSTANTS:
        if spec_key in handshake:
            _write_python_str_constant(out, py_name, str(handshake[spec_key]))

    # Bytes constants
    for spec_key, py_name in HANDSHAKE_BYTES_CONSTANTS:
        if spec_key in handshake:
            out.write(f'{py_name}: Final[bytes] = b"{handshake[spec_key]}"\n')

    # Config struct (hardcoded structure)
    out.write(
        "HANDSHAKE_CONFIG_STRUCT: Final = Struct(\n"
        "    \"ack_timeout_ms\" / Int16ub,\n"
        "    \"ack_retry_limit\" / Int8ub,\n"
        "    \"response_timeout_ms\" / Int32ub,\n"
        ")\n"
    )
    out.write("HANDSHAKE_CONFIG_SIZE: Final[int] = HANDSHAKE_CONFIG_STRUCT.sizeof()  # type: ignore\n")
    out.write("\n")


def _write_python_data_formats(out: TextIO, formats: dict[str, Any]) -> None:
    """Write Python data format constants with Construct structs."""
    for key, val in formats.items():
        name = key.upper()
        out.write(f'{name}: Final[str] = "{val}"\n')
        if key in CONSTRUCT_MAPPING:
            struct_name = name.replace("_FORMAT", "_STRUCT")
            out.write(f"{struct_name}: Final = {CONSTRUCT_MAPPING[key]}\n")

    out.write("DATASTORE_KEY_LEN_SIZE: Final[int] = DATASTORE_KEY_LEN_STRUCT.sizeof()  # type: ignore\n")
    out.write("DATASTORE_VALUE_LEN_SIZE: Final[int] = DATASTORE_VALUE_LEN_STRUCT.sizeof()  # type: ignore\n")
    out.write("CRC_COVERED_HEADER_SIZE: Final[int] = CRC_COVERED_HEADER_STRUCT.sizeof()  # type: ignore\n")
    out.write("CRC_SIZE: Final[int] = CRC_STRUCT.sizeof()  # type: ignore\n")
    out.write("MIN_FRAME_SIZE: Final[int] = CRC_COVERED_HEADER_SIZE + CRC_SIZE\n\n\n")


def _write_python_mqtt_subscriptions(out: TextIO, spec: dict[str, Any]) -> None:
    """Write MQTT subscription definitions."""
    subscriptions = spec.get("mqtt_subscriptions")
    if not subscriptions:
        return

    out.write("MQTT_COMMAND_SUBSCRIPTIONS: Final[tuple[tuple[Topic, tuple[str, ...], int], ...]] = (\n")
    action_lookup = _build_action_member_lookup(spec)

    for entry in subscriptions:
        topic_name = str(entry["topic"]).strip()
        segments = entry.get("segments") or []
        if not isinstance(segments, list):
            raise TypeError("mqtt_subscriptions.segments must be a list")

        qos = int(entry.get("qos", 0))
        topic_expr = f"Topic.{topic_name}"

        if segments:
            segment_expr = ", ".join(_mqtt_segment_expr(topic_name, str(s), action_lookup) for s in segments)
            out.write(f"    ({topic_expr}, ({segment_expr},), {qos}),\n")
        else:
            out.write(f"    ({topic_expr}, (), {qos}),\n")

    out.write(")\n\n\n")


def _write_python_actions(out: TextIO, spec: dict[str, Any]) -> None:
    """Write action enum classes grouped by prefix."""
    actions = spec.get("actions")
    if not actions:
        return

    # Group by prefix
    grouped: dict[str, list[dict[str, Any]]] = {}
    for action in actions:
        raw_name = str(action["name"])
        if "_" not in raw_name:
            raise ValueError(f"Action name must be PREFIX_SUFFIX (got {raw_name!r})")
        prefix, _ = raw_name.split("_", 1)
        grouped.setdefault(prefix, []).append(action)

    # Generate enum classes
    for prefix, group_actions in grouped.items():
        out.write(f"class {_action_group_class_name(prefix)}(StrEnum):\n")
        for action in group_actions:
            _, suffix = str(action["name"]).split("_", 1)
            out.write(f"    {suffix} = \"{action['value']}\"  # {action['description']}\n")
        out.write("\n\n")


def _write_python_commands(out: TextIO, spec: dict[str, Any]) -> None:
    """Write Command enum and related sets."""
    out.write("class Command(IntEnum):\n")
    ack_only: list[str] = []
    response_only: list[str] = []

    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']}\n")
        if cmd.get("requires_ack", False):
            ack_only.append(f"Command.{cmd['name']}.value")
        if cmd.get("expects_direct_response", False):
            response_only.append(f"Command.{cmd['name']}.value")

    if ack_only:
        out.write("\n\nACK_ONLY_COMMANDS: frozenset[int] = frozenset({\n")
        for cmd_val in ack_only:
            out.write(f"    {cmd_val},\n")
        out.write("})\n")

    if response_only:
        out.write("\n# Commands that expect a direct response without a prior ACK.\n")
        out.write("# The MCU responds directly with CMD_*_RESP without sending STATUS_ACK first.\n")
        out.write("RESPONSE_ONLY_COMMANDS: frozenset[int] = frozenset({\n")
        for cmd_val in response_only:
            out.write(f"    {cmd_val},\n")
        out.write("})\n")


def generate_python(spec: dict[str, Any], out: TextIO) -> None:
    """Generate Python protocol module."""
    out.write(PY_HEADER + "\n")

    consts = spec["constants"]

    # Constants
    _write_py_constants(out, consts, REQUIRED_CONSTANTS, required=True)
    _write_py_constants(out, consts, OPTIONAL_CONSTANTS, required=False)
    out.write("\n")

    # Handshake
    handshake = spec.get("handshake", {})
    if handshake:
        _write_python_handshake(out, handshake)

    # Compression types
    compression = spec.get("compression", {})
    if compression:
        out.write("class CompressionType(IntEnum):\n")
        for key, value in compression.items():
            out.write(f"    {key.upper()} = {value}\n")
        out.write("\n\n")

    # Capabilities
    capabilities = spec.get("capabilities", {})
    if capabilities:
        for key, value in capabilities.items():
            out.write(f"CAPABILITY_{key.upper()}: Final[int] = {value}\n")
        out.write("\n")

    # Data formats
    formats = spec.get("data_formats", {})
    if formats:
        _write_python_data_formats(out, formats)

    # MQTT suffixes
    mqtt_suffixes = spec.get("mqtt_suffixes", {})
    if mqtt_suffixes:
        for key, value in mqtt_suffixes.items():
            out.write(f'MQTT_SUFFIX_{key.upper()}: Final[str] = "{value}"\n')
        out.write("\n\n")

    # MQTT defaults
    mqtt_defaults = spec.get("mqtt_defaults", {})
    if mqtt_defaults and "default_topic_prefix" in mqtt_defaults:
        _write_python_str_constant(out, "MQTT_DEFAULT_TOPIC_PREFIX", str(mqtt_defaults["default_topic_prefix"]))
        out.write("\n")

    # Status reasons
    status_reasons = spec.get("status_reasons", {})
    if status_reasons:
        for key in sorted(status_reasons.keys()):
            _write_python_str_constant(out, f"STATUS_REASON_{str(key).upper()}", str(status_reasons[key]))
        out.write("\n")

    # MQTT wildcards
    out.write('MQTT_WILDCARD_SINGLE: Final[str] = "+"\n')
    out.write('MQTT_WILDCARD_MULTI: Final[str] = "#"\n\n\n')

    # Topics enum
    if "topics" in spec:
        out.write("class Topic(StrEnum):\n")
        for topic in spec["topics"]:
            out.write(f"    {topic['name']} = \"{topic['value']}\"  # {topic['description']}\n")
        out.write("\n\n")

    # Action enums
    _write_python_actions(out, spec)

    # MQTT subscriptions (after action enums)
    _write_python_mqtt_subscriptions(out, spec)

    # Status enum
    out.write("class Status(IntEnum):\n")
    for status in spec["statuses"]:
        out.write(f"    {status['name']} = {status['value']}  # {status['description']}\n")
    out.write("\n\n")

    # Commands
    _write_python_commands(out, spec)


# =============================================================================
# Main
# =============================================================================


def main() -> None:
    """Parse arguments and generate bindings."""
    default_spec = Path(__file__).resolve().parent / "spec.toml"
    repo_root = Path(__file__).resolve().parents[2]
    default_cpp = repo_root / "openwrt-library-arduino" / "src" / "protocol" / "rpc_protocol.h"
    default_py = repo_root / "openwrt-mcu-bridge" / "mcubridge" / "protocol" / "protocol.py"

    parser = argparse.ArgumentParser(description="Generate protocol bindings")
    parser.add_argument("--spec", type=Path, default=default_spec, help=f"Path to spec.toml (default: {default_spec})")
    parser.add_argument("--cpp", type=Path, help=f"Output C++ header (default: {default_cpp})")
    parser.add_argument("--py", type=Path, help=f"Output Python module (default: {default_py})")
    args = parser.parse_args()

    if args.cpp is None and args.py is None:
        args.cpp = default_cpp
        args.py = default_py

    with args.spec.open("rb") as f:
        spec = tomllib.load(f)

    if args.cpp is not None:
        args.cpp.parent.mkdir(parents=True, exist_ok=True)
        with args.cpp.open("w", encoding="utf-8") as f:
            generate_cpp(spec, f)
        sys.stdout.write(f"Generated {args.cpp}\n")

    if args.py is not None:
        args.py.parent.mkdir(parents=True, exist_ok=True)
        with args.py.open("w", encoding="utf-8") as f:
            generate_python(spec, f)
        sys.stdout.write(f"Generated {args.py}\n")


if __name__ == "__main__":
    main()
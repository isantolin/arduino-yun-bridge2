#!/bin/sh /etc/rc.common
# YunBridge Daemon Init Script - Refactor 10/10 (Flash Protection & Py3.13)

START=99
STOP=10
USE_PROCD=1

# [DEPENDENCIAS] Esperar a que Mosquitto y la red estén listos para evitar race conditions
DEPENDS="mosquitto network"

start_service() {
    # [FLASH GUARD] Crear directorios volátiles en RAMFS antes de iniciar
    # Esto evita que el daemon escriba colas o sockets en la memoria Flash
    mkdir -p /tmp/yunbridge/spool
    mkdir -p /tmp/run/yunbridge
    
    # Asegurar permisos para que el usuario del servicio pueda escribir
    chmod 777 /tmp/yunbridge/spool
    chmod 777 /tmp/run/yunbridge

    procd_open_instance

    # [EJECUCIÓN] Invocación directa optimizada (-O) para Python 3.13
    # Se asume que el paquete está instalado en site-packages
    procd_set_param command /usr/bin/python3 -O -m yunbridge

    # [VARIABLES] Entorno crítico
    procd_set_param env PYTHONPATH=/usr/lib/python3.13/site-packages
    # Forzar el spool en RAM explícitamente como fallback de seguridad
    procd_set_param env MQTT_SPOOL_DIR=/tmp/yunbridge/spool

    # [RESILIENCIA] Reinicio automático: Espera 3600s antes de rendirse, intenta infinito con backoff de 5s
    procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-0}

    # [WATCHDOG] Integración con el watchdog del sistema (procd)
    # Si el script de python no hace "touch" cada 60s, el sistema reinicia el servicio
    local watchdog_ms="${YUNBRIDGE_PROCD_WATCHDOG_MS:-60000}"
    procd_set_param watchdog "$watchdog_ms"
    procd_set_param env YUNBRIDGE_PROCD_WATCHDOG_MS="$watchdog_ms"

    # [LOGGING] Redirigir stdout/stderr a syslog (logread)
    # Esencial para no saturar buffers y depurar con herramientas nativas
    procd_set_param stdout 1
    procd_set_param stderr 1

    procd_close_instance
}

#!/usr/bin/env python3
"""Protocol binding generator for Yun Bridge v2.

Reads spec.toml and generates:
1. Python bindings (yunbridge/rpc/protocol.py)
2. C++ bindings (openwrt-library-arduino/src/protocol/rpc_protocol.h)
"""

import argparse
import json
import sys
import textwrap
from pathlib import Path
from typing import Any, TextIO
import tomllib


HEADER = """/*
 * This file is part of Arduino Yun Ecosystem v2.
 * Copyright (C) 2025 Ignacio Santolin and contributors
 *
 * Auto-generated by tools/protocol/generate.py. DO NOT EDIT.
 */"""

PY_HEADER = """\"\"\"Auto-generated protocol bindings. Do not edit manually.\"\"\"
from __future__ import annotations
import struct
from enum import IntEnum, StrEnum
from typing import Final
"""


def _write_python_str_constant(
    out: TextIO,
    name: str,
    value: str,
    *,
    max_line_length: int = 120,
    wrap_width: int = 88,
) -> None:
    prefix = f"{name}: Final[str] = "
    literal = json.dumps(value)
    line = f"{prefix}{literal}"
    if len(line) <= max_line_length:
        out.write(f"{line}\n")
        return

    chunks = textwrap.wrap(
        value,
        width=wrap_width,
        break_long_words=False,
        break_on_hyphens=False,
    )
    if not chunks:
        out.write(f"{prefix}{literal}\n")
        return

    if len(chunks) > 1:
        chunks = [chunk + " " for chunk in chunks[:-1]] + [chunks[-1]]

    out.write(f"{name}: Final[str] = (\n")
    for chunk in chunks:
        out.write(f"    {json.dumps(chunk)}\n")
    out.write(")\n")


def generate_cpp(spec: dict[str, Any], out: TextIO) -> None:
    out.write(f"{HEADER}\n")
    out.write("#ifndef RPC_PROTOCOL_H\n#define RPC_PROTOCOL_H\n\n")
    out.write('#include <stdint.h>\n\n')

    out.write("namespace rpc {\n\n")

    consts = spec["constants"]
    out.write(
        f"constexpr uint8_t PROTOCOL_VERSION = {consts['protocol_version']};\n"
    )
    out.write(
        f"constexpr unsigned long RPC_DEFAULT_BAUDRATE = {consts['default_baudrate']};\n"
    )
    if "default_safe_baudrate" in consts:
        out.write(
            f"constexpr unsigned long RPC_DEFAULT_SAFE_BAUDRATE = {consts['default_safe_baudrate']};\n"
        )
    out.write(
        f"constexpr unsigned int RPC_BUFFER_SIZE = {consts['rpc_buffer_size']};\n\n"
    )
    if "max_payload_size" in consts:
        out.write(
            f"constexpr size_t MAX_PAYLOAD_SIZE = {consts['max_payload_size']};\n"
        )
    if "max_filepath_length" in consts:
        out.write(
            f"constexpr size_t RPC_MAX_FILEPATH_LENGTH = {consts['max_filepath_length']};\n"
        )
    if "max_datastore_key_length" in consts:
        out.write(
            f"constexpr size_t RPC_MAX_DATASTORE_KEY_LENGTH = {consts['max_datastore_key_length']};\n"
        )
    if "default_ack_timeout_ms" in consts:
        out.write(
            f"constexpr unsigned int RPC_DEFAULT_ACK_TIMEOUT_MS = {consts['default_ack_timeout_ms']};\n"
        )
    if "default_retry_limit" in consts:
        out.write(
            f"constexpr uint8_t RPC_DEFAULT_RETRY_LIMIT = {consts['default_retry_limit']};\n"
        )
    if "max_pending_tx_frames" in consts:
        out.write(
            f"constexpr uint8_t RPC_MAX_PENDING_TX_FRAMES = {consts['max_pending_tx_frames']};\n"
        )
    if "invalid_id_sentinel" in consts:
        out.write(
            f"constexpr uint16_t RPC_INVALID_ID_SENTINEL = {consts['invalid_id_sentinel']};\n"
        )
    if "response_offset" in consts:
        out.write(
            f"constexpr uint8_t RPC_RESPONSE_OFFSET = {consts['response_offset']};\n"
        )
    if "uint8_mask" in consts:
        out.write(
            f"constexpr uint8_t RPC_UINT8_MASK = {consts['uint8_mask']};\n"
        )
    if "uint16_max" in consts:
        out.write(
            f"constexpr uint16_t RPC_UINT16_MAX = {consts['uint16_max']};\n"
        )
    if "process_default_exit_code" in consts:
        out.write(
            f"constexpr uint8_t RPC_PROCESS_DEFAULT_EXIT_CODE = {consts['process_default_exit_code']};\n"
        )
    if "crc32_mask" in consts:
        out.write(
            f"constexpr uint32_t RPC_CRC32_MASK = {consts['crc32_mask']};\n"
        )
    if "crc_initial" in consts:
        out.write(
            f"constexpr uint32_t RPC_CRC_INITIAL = {consts['crc_initial']};\n"
        )
    if "crc_polynomial" in consts:
        out.write(
            f"constexpr uint32_t RPC_CRC_POLYNOMIAL = {consts['crc_polynomial']};\n"
        )
    if "frame_delimiter" in consts:
        out.write(
            f"constexpr uint8_t RPC_FRAME_DELIMITER = {consts['frame_delimiter']};\n"
        )
    if "digital_low" in consts:
        out.write(
            f"constexpr uint8_t RPC_DIGITAL_LOW = {consts['digital_low']};\n"
        )
    if "digital_high" in consts:
        out.write(
            f"constexpr uint8_t RPC_DIGITAL_HIGH = {consts['digital_high']};\n"
        )
    if "test_payload_byte" in consts:
        out.write(
            f"constexpr uint8_t RPC_TEST_PAYLOAD_BYTE = {consts['test_payload_byte']};\n"
        )
    if "test_marker_byte" in consts:
        out.write(
            f"constexpr uint8_t RPC_TEST_MARKER_BYTE = {consts['test_marker_byte']};\n"
        )
    if "test_exit_code" in consts:
        out.write(
            f"constexpr uint8_t RPC_TEST_EXIT_CODE = {consts['test_exit_code']};\n"
        )
    if "test_unknown_command_id" in consts:
        out.write(
            f"constexpr uint16_t RPC_TEST_UNKNOWN_COMMAND_ID = {consts['test_unknown_command_id']};\n"
        )
    if "status_code_min" in consts:
        out.write(
            f"constexpr uint8_t RPC_STATUS_CODE_MIN = {consts['status_code_min']};\n"
        )
    if "status_code_max" in consts:
        out.write(
            f"constexpr uint8_t RPC_STATUS_CODE_MAX = {consts['status_code_max']};\n"
        )
    if "system_command_min" in consts:
        out.write(
            f"constexpr uint16_t RPC_SYSTEM_COMMAND_MIN = {consts['system_command_min']};\n"
        )
    if "system_command_max" in consts:
        out.write(
            f"constexpr uint16_t RPC_SYSTEM_COMMAND_MAX = {consts['system_command_max']};\n"
        )
    if "gpio_command_min" in consts:
        out.write(
            f"constexpr uint16_t RPC_GPIO_COMMAND_MIN = {consts['gpio_command_min']};\n"
        )
    out.write("\n")

    handshake = spec.get("handshake", {})
    if handshake:
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_NONCE_LENGTH = {handshake['nonce_length']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_TAG_LENGTH = {handshake['tag_length']};\n"
        )
        out.write("constexpr unsigned int RPC_HANDSHAKE_CONFIG_SIZE = 7;\n")
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_ACK_TIMEOUT_MIN_MS = {handshake['ack_timeout_min_ms']};\n"
        )
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_ACK_TIMEOUT_MAX_MS = {handshake['ack_timeout_max_ms']};\n"
        )
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS = {handshake['response_timeout_min_ms']};\n"
        )
        out.write(
            f"constexpr uint32_t RPC_HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS = {handshake['response_timeout_max_ms']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RETRY_LIMIT_MIN = {handshake['retry_limit_min']};\n"
        )
        out.write(
            f"constexpr unsigned int RPC_HANDSHAKE_RETRY_LIMIT_MAX = {handshake['retry_limit_max']};\n\n"
        )

    out.write("enum class StatusCode : uint8_t {\n")
    for status in spec["statuses"]:
        out.write(f"    STATUS_{status['name']} = {status['value']},\n")
    out.write("};\n\n")

    out.write("enum class CommandId : uint16_t {\n")
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']},\n")
    out.write("};\n\n")

    out.write("""
constexpr uint8_t to_underlying(StatusCode value) {
    return static_cast<uint8_t>(value);
}

constexpr uint16_t to_underlying(CommandId value) {
    return static_cast<uint16_t>(value);
}
""")
    out.write("} // namespace rpc\n#endif\n")


def generate_python(spec: dict[str, Any], out: TextIO) -> None:
    out.write(PY_HEADER + "\n")
    consts = spec["constants"]
    out.write(f"PROTOCOL_VERSION: Final[int] = {consts['protocol_version']}\n")
    out.write(f"DEFAULT_BAUDRATE: Final[int] = {consts['default_baudrate']}\n")
    if "default_safe_baudrate" in consts:
        out.write(
            f"DEFAULT_SAFE_BAUDRATE: Final[int] = {consts['default_safe_baudrate']}\n"
        )
    out.write(f"MAX_PAYLOAD_SIZE: Final[int] = {consts['max_payload_size']}\n")
    out.write(f"RPC_BUFFER_SIZE: Final[int] = {consts['rpc_buffer_size']}\n")
    if "max_filepath_length" in consts:
        out.write(
            f"MAX_FILEPATH_LENGTH: Final[int] = {consts['max_filepath_length']}\n"
        )
    if "max_datastore_key_length" in consts:
        out.write(
            f"MAX_DATASTORE_KEY_LENGTH: Final[int] = {consts['max_datastore_key_length']}\n"
        )
    if "default_ack_timeout_ms" in consts:
        out.write(
            f"DEFAULT_ACK_TIMEOUT_MS: Final[int] = {consts['default_ack_timeout_ms']}\n"
        )
    if "default_retry_limit" in consts:
        out.write(
            f"DEFAULT_RETRY_LIMIT: Final[int] = {consts['default_retry_limit']}\n"
        )
    if "max_pending_tx_frames" in consts:
        out.write(
            f"MAX_PENDING_TX_FRAMES: Final[int] = {consts['max_pending_tx_frames']}\n"
        )
    if "invalid_id_sentinel" in consts:
        out.write(
            f"INVALID_ID_SENTINEL: Final[int] = {consts['invalid_id_sentinel']}\n"
        )
    if "response_offset" in consts:
        out.write(
            f"RESPONSE_OFFSET: Final[int] = {consts['response_offset']}\n"
        )
    if "uint8_mask" in consts:
        out.write(
            f"UINT8_MASK: Final[int] = {consts['uint8_mask']}\n"
        )
    if "uint16_max" in consts:
        out.write(
            f"UINT16_MAX: Final[int] = {consts['uint16_max']}\n"
        )
    if "process_default_exit_code" in consts:
        out.write(
            f"PROCESS_DEFAULT_EXIT_CODE: Final[int] = {consts['process_default_exit_code']}\n"
        )
    if "crc32_mask" in consts:
        out.write(
            f"CRC32_MASK: Final[int] = {consts['crc32_mask']}\n"
        )
    if "crc_initial" in consts:
        out.write(
            f"CRC_INITIAL: Final[int] = {consts['crc_initial']}\n"
        )
    if "crc_polynomial" in consts:
        out.write(
            f"CRC_POLYNOMIAL: Final[int] = {consts['crc_polynomial']}\n"
        )
    if "frame_delimiter" in consts:
        out.write(
            f"FRAME_DELIMITER: Final[bytes] = bytes([{consts['frame_delimiter']}])\n"
        )
    if "digital_low" in consts:
        out.write(
            f"DIGITAL_LOW: Final[int] = {consts['digital_low']}\n"
        )
    if "digital_high" in consts:
        out.write(
            f"DIGITAL_HIGH: Final[int] = {consts['digital_high']}\n"
        )
    if "test_payload_byte" in consts:
        out.write(
            f"TEST_PAYLOAD_BYTE: Final[int] = {consts['test_payload_byte']}\n"
        )
    if "test_marker_byte" in consts:
        out.write(
            f"TEST_MARKER_BYTE: Final[int] = {consts['test_marker_byte']}\n"
        )
    if "test_exit_code" in consts:
        out.write(
            f"TEST_EXIT_CODE: Final[int] = {consts['test_exit_code']}\n"
        )
    if "test_unknown_command_id" in consts:
        out.write(
            f"TEST_UNKNOWN_COMMAND_ID: Final[int] = {consts['test_unknown_command_id']}\n"
        )
    if "status_code_min" in consts:
        out.write(
            f"STATUS_CODE_MIN: Final[int] = {consts['status_code_min']}\n"
        )
    if "status_code_max" in consts:
        out.write(
            f"STATUS_CODE_MAX: Final[int] = {consts['status_code_max']}\n"
        )
    if "system_command_min" in consts:
        out.write(
            f"SYSTEM_COMMAND_MIN: Final[int] = {consts['system_command_min']}\n"
        )
    if "system_command_max" in consts:
        out.write(
            f"SYSTEM_COMMAND_MAX: Final[int] = {consts['system_command_max']}\n"
        )
    if "gpio_command_min" in consts:
        out.write(
            f"GPIO_COMMAND_MIN: Final[int] = {consts['gpio_command_min']}\n"
        )
    out.write("\n")

    handshake = spec.get("handshake", {})
    if handshake:
        out.write(f"HANDSHAKE_NONCE_LENGTH: Final[int] = {handshake['nonce_length']}\n")
        out.write(f"HANDSHAKE_TAG_LENGTH: Final[int] = {handshake['tag_length']}\n")
        out.write(
            f"HANDSHAKE_TAG_ALGORITHM: Final[str] = \"{handshake['tag_algorithm']}\"\n"
        )
        _write_python_str_constant(
            out,
            "HANDSHAKE_TAG_DESCRIPTION",
            handshake["tag_description"],
        )
        out.write(
            f"HANDSHAKE_CONFIG_FORMAT: Final[str] = \"{handshake['config_format']}\"\n"
        )
        _write_python_str_constant(
            out,
            "HANDSHAKE_CONFIG_DESCRIPTION",
            handshake["config_description"],
        )
        out.write(
            "HANDSHAKE_CONFIG_SIZE: Final[int] = struct.calcsize(HANDSHAKE_CONFIG_FORMAT)\n"
        )
        out.write(
            f"HANDSHAKE_ACK_TIMEOUT_MIN_MS: Final[int] = {handshake['ack_timeout_min_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_ACK_TIMEOUT_MAX_MS: Final[int] = {handshake['ack_timeout_max_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RESPONSE_TIMEOUT_MIN_MS: Final[int] = {handshake['response_timeout_min_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RESPONSE_TIMEOUT_MAX_MS: Final[int] = {handshake['response_timeout_max_ms']}\n"
        )
        out.write(
            f"HANDSHAKE_RETRY_LIMIT_MIN: Final[int] = {handshake['retry_limit_min']}\n"
        )
        out.write(
            f"HANDSHAKE_RETRY_LIMIT_MAX: Final[int] = {handshake['retry_limit_max']}\n\n"
        )

    formats = spec.get("data_formats", {})
    if formats:
        if "uint8_format" in formats:
            out.write(f"UINT8_FORMAT: Final[str] = \"{formats['uint8_format']}\"\n")
        if "uint16_format" in formats:
            out.write(f"UINT16_FORMAT: Final[str] = \"{formats['uint16_format']}\"\n")
        if "uint32_format" in formats:
            out.write(f"UINT32_FORMAT: Final[str] = \"{formats['uint32_format']}\"\n")
        if "pin_read_format" in formats:
            out.write(f"PIN_READ_FORMAT: Final[str] = \"{formats['pin_read_format']}\"\n")
        if "pin_write_format" in formats:
            out.write(f"PIN_WRITE_FORMAT: Final[str] = \"{formats['pin_write_format']}\"\n")
        out.write(
            f"DATASTORE_KEY_LEN_FORMAT: Final[str] = \"{formats['datastore_key_len_format']}\"\n"
        )
        out.write(
            "DATASTORE_KEY_LEN_SIZE: Final[int] = struct.calcsize(DATASTORE_KEY_LEN_FORMAT)\n"
        )
        out.write(
            f"DATASTORE_VALUE_LEN_FORMAT: Final[str] = \"{formats['datastore_value_len_format']}\"\n"
        )
        out.write(
            "DATASTORE_VALUE_LEN_SIZE: Final[int] = struct.calcsize(DATASTORE_VALUE_LEN_FORMAT)\n"
        )
        out.write(
            f"CRC_COVERED_HEADER_FORMAT: Final[str] = \"{formats['crc_covered_header_format']}\"\n"
        )
        out.write(
            "CRC_COVERED_HEADER_SIZE: Final[int] = struct.calcsize(CRC_COVERED_HEADER_FORMAT)\n"
        )
        out.write(f"CRC_FORMAT: Final[str] = \"{formats['crc_format']}\"\n")
        out.write("CRC_SIZE: Final[int] = struct.calcsize(CRC_FORMAT)\n")
        out.write("MIN_FRAME_SIZE: Final[int] = CRC_COVERED_HEADER_SIZE + CRC_SIZE\n\n\n")

    mqtt_suffixes = spec.get("mqtt_suffixes", {})
    if mqtt_suffixes:
        for key, value in mqtt_suffixes.items():
            name = f"MQTT_SUFFIX_{key.upper()}"
            out.write(f'{name}: Final[str] = "{value}"\n')
        out.write("\n\n")

    if "topics" in spec:
        out.write("class Topic(StrEnum):\n")
        for topic in spec["topics"]:
            out.write(
                f"    {topic['name']} = \"{topic['value']}\"  # {topic['description']}\n"
            )
        out.write("\n\n")

    mqtt_subscriptions = spec.get("mqtt_subscriptions")
    if mqtt_subscriptions:
        out.write(
            "MQTT_COMMAND_SUBSCRIPTIONS: Final[tuple[tuple[Topic, tuple[str, ...], int], ...]] = (\n"
        )
        for entry in mqtt_subscriptions:
            topic_name = str(entry["topic"]).strip()
            segments = entry.get("segments") or []
            if not isinstance(segments, list):
                raise TypeError("mqtt_subscriptions.segments must be a list")
            qos = int(entry.get("qos", 0))
            topic_expr = f"Topic.{topic_name}"
            if segments:
                segment_expr = ", ".join(json.dumps(str(seg)) for seg in segments)
                out.write(f"    ({topic_expr}, ({segment_expr},), {qos}),\n")
            else:
                out.write(f"    ({topic_expr}, (), {qos}),\n")
        # flake8 expects two blank lines between top-level definitions.
        out.write(")\n\n\n")

    if "actions" in spec:
        out.write("class Action(StrEnum):\n")
        for action in spec["actions"]:
            out.write(
                f"    {action['name']} = \"{action['value']}\"  # {action['description']}\n"
            )
        out.write("\n\n")

    out.write("class Status(IntEnum):\n")
    for status in spec["statuses"]:
        out.write(
            f"    {status['name']} = {status['value']}  # {status['description']}\n"
        )
    out.write("\n\n")

    out.write("class Command(IntEnum):\n")
    ack_only_commands = []
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']}\n")
        if cmd.get("requires_ack", False):
            ack_only_commands.append(f"Command.{cmd['name']}.value")

    if ack_only_commands:
        out.write("\n\nACK_ONLY_COMMANDS: frozenset[int] = frozenset({\n")
        for cmd_val in ack_only_commands:
            out.write(f"    {cmd_val},\n")
        out.write("})\n")


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate protocol bindings")
    parser.add_argument("--spec", type=Path, required=True, help="Path to spec.toml")
    parser.add_argument("--cpp", type=Path, help="Output C++ header")
    parser.add_argument("--py", type=Path, help="Output Python module")
    args = parser.parse_args()

    with args.spec.open("rb") as f:
        spec = tomllib.load(f)

    if args.cpp:
        with args.cpp.open("w") as f:
            generate_cpp(spec, f)
        sys.stdout.write(f"Generated {args.cpp}\n")

    if args.py:
        with args.py.open("w") as f:
            generate_python(spec, f)
        sys.stdout.write(f"Generated {args.py}\n")


if __name__ == "__main__":
    main()

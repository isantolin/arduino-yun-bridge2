#!/usr/bin/env python3
"""Protocol binding generator for Yun Bridge v2.

Reads spec.toml and generates:
1. Python bindings (yunbridge/rpc/protocol.py)
2. C++ bindings (openwrt-library-arduino/src/protocol/rpc_protocol.h)
"""
import argparse
import sys
from pathlib import Path
from typing import Any, TextIO

try:
    import tomllib  # type: ignore
except ImportError:
    try:
        import tomli as tomllib  # type: ignore
    except ImportError:
        sys.exit("Error: Python 3.11+ or 'tomli' is required.")

HEADER = """/*
 * This file is part of Arduino Yun Ecosystem v2.
 * Copyright (C) 2025 Ignacio Santolin and contributors
 *
 * Auto-generated by tools/protocol/generate.py. DO NOT EDIT.
 */"""

PY_HEADER = """\"\"\"Auto-generated protocol bindings. Do not edit manually.\"\"\"
from __future__ import annotations
import struct
from enum import IntEnum
from typing import Final
"""

def generate_cpp(spec: dict[str, Any], out: TextIO) -> None:
    out.write(f"{HEADER}\n")
    out.write("#ifndef RPC_PROTOCOL_H\n#define RPC_PROTOCOL_H\n\n")
    out.write("#include <cstdint>\n#include <type_traits>\n#include \"rpc_frame.h\"\n\n")
    
    consts = spec["constants"]
    out.write(f"static_assert(rpc::PROTOCOL_VERSION == {consts['protocol_version']}, \"Version mismatch\");\n")
    out.write(f"constexpr unsigned int RPC_BUFFER_SIZE = {consts['rpc_buffer_size']};\n\n")
    
    out.write("namespace rpc {\n\n")
    
    out.write("enum class StatusCode : uint8_t {\n")
    for status in spec["statuses"]:
        out.write(f"    STATUS_{status['name']} = {status['value']},\n")
    out.write("};\n\n")

    out.write("enum class CommandId : uint16_t {\n")
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']},\n")
    out.write("};\n\n")
    
    out.write("""template <typename Enum>
constexpr auto to_underlying(Enum value) noexcept -> typename std::underlying_type<Enum>::type {
    return static_cast<typename std::underlying_type<Enum>::type>(value);
}
""")
    out.write("} // namespace rpc\n#endif\n")

def generate_python(spec: dict[str, Any], out: TextIO) -> None:
    out.write(PY_HEADER + "\n")
    consts = spec["constants"]
    out.write(f"PROTOCOL_VERSION: Final[int] = {consts['protocol_version']}\n")
    out.write(f"MAX_PAYLOAD_SIZE: Final[int] = {consts['max_payload_size']}\n\n")
    
    out.write("class Status(IntEnum):\n")
    for status in spec["statuses"]:
        out.write(f"    {status['name']} = {status['value']}  # {status['description']}\n")
    out.write("\n")

    out.write("class Command(IntEnum):\n")
    for cmd in spec["commands"]:
        out.write(f"    {cmd['name']} = {cmd['value']}\n")

def main() -> None:
    parser = argparse._ArgumentParser() # Avoid private usage if strict but argparse is standard
    parser = argparse.ArgumentParser(description="Generate protocol bindings")
    parser.add_argument("--spec", type=Path, required=True, help="Path to spec.toml")
    parser.add_argument("--cpp", type=Path, help="Output C++ header")
    parser.add_argument("--py", type=Path, help="Output Python module")
    args = parser.parse_args()

    with args.spec.open("rb") as f:
        spec = tomllib.load(f)

    if args.cpp:
        with args.cpp.open("w") as f:
            generate_cpp(spec, f)
        print(f"Generated {args.cpp}")

    if args.py:
        with args.py.open("w") as f:
            generate_python(spec, f)
        print(f"Generated {args.py}")

if __name__ == "__main__":
    main()